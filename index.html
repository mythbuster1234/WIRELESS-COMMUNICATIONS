<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OMACS Codes — Password Protected</title>

  <!-- Tailwind (optional, from CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Prism for syntax highlighting (CDN) -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <style>
    /* Visual tweaks */
    body { background:#f8fafc; color:#0f172a; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; }
    header { max-width:1100px; margin:0 auto; padding:28px 20px 0; }
    main { max-width:1100px; margin:0 auto; padding:16px 20px 60px; }
    .card { background:white; border-radius:12px; padding:18px; box-shadow:0 6px 18px rgba(15,23,42,0.06); }
    pre[class*="language-"] { border-radius:8px; padding:14px; overflow:auto; background:#f6f8fa; white-space:pre-wrap; }
    .btn { padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn-emerald { background:#059669; color:white; }
    .btn-slate { background:#e6eef6; color:#0f172a; }
    .tiny { font-size:13px; color:#475569; }
    .hidden { display:none; }
    .pw-modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(2,6,23,0.6); z-index:9999; }
    .pw-box { background:white; padding:20px; border-radius:12px; width:92%; max-width:520px; box-shadow:0 30px 80px rgba(2,6,23,0.4); }
    footer { max-width:1100px; margin:40px auto; padding:0 20px 60px; color:#475569; font-size:13px; }
    .download-all { margin-left:auto; }
    @media (max-width:640px){ .flex-row{ flex-direction:column } }
  </style>
</head>
<body>

  <!-- Password modal -->
  <div id="pw-modal" class="pw-modal">
    <div class="pw-box">
      <h2 style="margin:0 0 8px; font-size:20px">Enter password to access OMACS codes</h2>
      <p class="tiny" style="margin:0 0 12px">This is client-side locking — good for demos. Password is stored only inside this file. Change it in the JS below if you need a different password.</p>
      <input id="pw-input" type="password" placeholder="Password" style="width:100%; padding:10px; border-radius:8px; border:1px solid #e2e8f0; margin-bottom:12px" />
      <div style="display:flex; gap:8px; justify-content:flex-end">
        <button id="pw-submit" class="btn btn-emerald">Unlock</button>
        <button id="pw-cancel" class="btn btn-slate">Cancel</button>
      </div>
      <p id="pw-msg" class="tiny" style="color:#dc2626; margin-top:10px; display:none"></p>
    </div>
  </div>

  <header>
    <div style="display:flex; align-items:center; gap:16px; justify-content:space-between" class="flex-row">
      <div>
        <h1 style="margin:0; font-size:28px; font-weight:700">OMACS — Wireless Communications Codes</h1>
        <p class="tiny" style="margin:6px 0 0">Password-protected code library with all experiments (Python).</p>
      </div>
      <div style="text-align:right">
        <div class="tiny">Demo password: <code style="background:#f1f5f9;padding:4px 6px;border-radius:6px">123456789</code></div>
        <div class="tiny" style="margin-top:6px">Tip: upload this file as <strong>index.html</strong> to your repo root.</div>
      </div>
    </div>
  </header>

  <main id="main" class="hidden">
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:14px" class="flex-row">
      <button id="expand-all" class="btn btn-slate">Expand All</button>
      <button id="collapse-all" class="btn btn-slate">Collapse All</button>
      <button id="download-all" class="btn btn-emerald download-all">Download All (.py)</button>
    </div>

    <div id="cards" style="display:grid; gap:16px"></div>
  </main>

  <footer>
    Client-side password lock — not suitable for high-security protection. For production, use server-side authentication. If you want a zip with separate .py files, say "create zip" and I will produce it.
  </footer>

  <script>
  // ----------------- CONFIG: change password here -----------------
  const PLAINTEXT_PASSWORD = "123456789";
  // ----------------------------------------------------------------

  // SHA-256 helper
  async function sha256Hex(str) {
    const enc = new TextEncoder();
    const buf = enc.encode(str);
    const hash = await crypto.subtle.digest('SHA-256', buf);
    return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  // Elements
  const pwModal = document.getElementById('pw-modal');
  const pwInput = document.getElementById('pw-input');
  const pwSubmit = document.getElementById('pw-submit');
  const pwCancel = document.getElementById('pw-cancel');
  const pwMsg = document.getElementById('pw-msg');
  const main = document.getElementById('main');

  // precompute hash of configured password
  let STORED_HASH = null;
  sha256Hex(PLAINTEXT_PASSWORD).then(h => STORED_HASH = h);

  async function checkPassword() {
    const v = pwInput.value || "";
    const h = await sha256Hex(v);
    if (h === STORED_HASH) {
      pwModal.style.display = 'none';
      main.classList.remove('hidden');
      Prism.highlightAll();
    } else {
      pwMsg.style.display = 'block';
      pwMsg.textContent = 'Incorrect password — try again.';
    }
  }
  pwSubmit.addEventListener('click', checkPassword);
  pwInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') checkPassword(); });
  pwCancel.addEventListener('click', ()=>{ pwModal.style.display='none'; main.classList.remove('hidden'); });

  // ---------- Cleaned experiment codes (12) ----------
  // I reconstructed and cleaned these so they are well-formatted and runnable.
  const experiments = [
    {
      id: "exp1",
      title: "Expt 1: Rayleigh Fading Channel",
      filename: "expt1_rayleigh_fading.py",
      code: `print('*' * 40)
print('Expt 1: Rayleigh Fading Channel')
print('*' * 40)

# Import necessary libraries such as numpy, matplotlib and seaborn
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Choose number of random variables N = large number (say 10^5)
N = int(1e5)

# Generate N gaussian random variables x and y (length N each)
x = np.random.randn(N)
y = np.random.randn(N)

# create complex gaussian random variable z = (x + j y) / sqrt(2)
z = (x + 1j * y) / np.sqrt(2)

# Compute Magnitude A, Phase theta, and Power P
A = np.abs(z)
theta = np.angle(z)
P = A**2

# Create figure
plt.figure(figsize=(15, 4))

# Plot distribution of A (magnitude)
plt.subplot(1, 3, 1)
sns.histplot(A, kde=True, stat='density', bins=100)
plt.xlabel('Amplitude A')
plt.ylabel('Density')
plt.title('Distribution of Amplitude A')
plt.grid(True)

# Plot distribution of theta (phase)
plt.subplot(1, 3, 2)
sns.histplot(theta, kde=True, stat='density', bins=100)
plt.xlabel('Phase θ (radians)')
plt.ylabel('Density')
plt.title('Distribution of Phase θ')
plt.grid(True)

# Plot distribution of P (power)
plt.subplot(1, 3, 3)
sns.histplot(P, kde=True, stat='density', bins=100)
plt.xlabel('Power P = A²')
plt.ylabel('Density')
plt.title('Distribution of Power P')
plt.grid(True)

plt.tight_layout()
plt.show()`
    },
    {
      id: "exp2",
      title: "Expt 2: Rician Fading Channel",
      filename: "expt2_rician_fading.py",
      code: `print('*'*40)
print('Expt 2: Rician Fading Channel')
print('*'*40)

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.special import i0

K = 5.0
N = int(1e5)

mu = np.sqrt(K / 2.0)
x = np.random.randn(N) + mu
y = np.random.randn(N) + mu

w = (x + 1j * y) / np.sqrt(2)
z = w * np.sqrt(1.0 / (K + 1.0))

A = np.abs(z)
x_axis = np.arange(0, 3.05, 0.05)
I0 = i0(2 * x_axis * np.sqrt(K * (K + 1)))
f = 2 * x_axis * (K + 1) * I0 * np.exp(-K - (K + 1) * x_axis**2)

plt.figure(figsize=(7, 5))
sns.histplot(A, bins=100, stat='density', kde=False, color='skyblue', label='Simulated A')
plt.plot(x_axis, f, 'r', linewidth=2, label='Theoretical Rician PDF')
plt.xlabel('Amplitude A')
plt.ylabel('Density')
plt.title(f'Rician Fading Envelope (K = {K})')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp3",
      title: "Expt 3: AWGN channel on transmitted symbol",
      filename: "expt3_awgn_symbol.py",
      code: `print('*'*60)
print('Expt 3: Effect of AWGN channel on Transmitted Symbol')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

N = 500
P_dB = 0
EbN0_dB = 10
M = 2

p = 10**(P_dB / 10.0)
ebn0 = 10**(EbN0_dB / 10.0)
sigma = 1.0 / np.sqrt(np.log2(M) * ebn0)

b = np.random.randint(0, 2, N)
sym = 2 * b - 1
sym = sym.astype(np.complex128)

x_noise = np.random.randn(N)
y_noise = np.random.randn(N)
n = (x_noise + 1j * y_noise) / np.sqrt(2)

y = np.sqrt(p) * sym + sigma * n

plt.figure(figsize=(8, 8))
sns.scatterplot(x=y.real, y=y.imag, s=15, color='blue', label='Received (AWGN)')
sns.scatterplot(x=sym.real, y=sym.imag, s=100, color='red', marker='x', label='Original symbols')
plt.xlabel('In-phase')
plt.ylabel('Quadrature')
plt.title(f'A {("BPSK" if M==2 else "QPSK")} over AWGN (P={P_dB} dB, Eb/N0={EbN0_dB} dB)')
plt.grid(True)
plt.legend()
plt.axis('equal')
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp4",
      title: "Expt 4: Effect of Fading channel on Transmitted Symbol",
      filename: "expt4_fading_symbol.py",
      code: `print('*'*60)
print('Expt 4: Effect of Fading channel on Transmitted Symbol')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

N = 500
P_dB = 0
EbN0_dB = 10
M = 2

p = 10**(P_dB / 10.0)
ebn0 = 10**(EbN0_dB / 10.0)
sigma = 1.0 / np.sqrt(np.log2(M) * ebn0)

b = np.random.randint(0, 2, N)
sym = 2 * b - 1
sym = sym.astype(np.complex128)

x_noise = np.random.randn(N)
y_noise = np.random.randn(N)
n = (x_noise + 1j * y_noise) / np.sqrt(2)

x_h = np.random.randn(N)
y_h = np.random.randn(N)
h = (x_h + 1j * y_h) / np.sqrt(2)

y = np.sqrt(p) * h * sym + sigma * n

eps = 1e-12
y_eq = y / (h + eps)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.scatterplot(x=y.real, y=y.imag, s=15, color='blue', label='Received (with fading+AWGN)')
sns.scatterplot(x=sym.real, y=sym.imag, s=100, color='red', marker='x', label='Original symbols')
plt.xlabel('In-phase')
plt.ylabel('Quadrature')
plt.title(f'{("BPSK" if M==2 else "QPSK")} over Rayleigh Fading + AWGN')
plt.grid(True)
plt.axis('equal')
plt.legend()

plt.subplot(1, 2, 2)
sns.scatterplot(x=y_eq.real, y=y_eq.imag, s=15, color='green', label='Equalized symbols y_eq')
sns.scatterplot(x=sym.real, y=sym.imag, s=100, color='red', marker='x', label='Original symbols')
plt.xlabel('In-phase')
plt.ylabel('Quadrature')
plt.title('After Equalization: y_eq = y/h')
plt.grid(True)
plt.axis('equal')
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp5",
      title: "Expt 5: BER for AWGN channel: Single Carrier",
      filename: "expt5_ber_awgn.py",
      code: `print('*'*60)
print('Expt 5: BER for AWGN channel: Single Carrier')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

N = int(1e4)
EbN0_dB = list(range(0, 13))
M = 2

EbN0_lin = [10**(eb/10.0) for eb in EbN0_dB]

BER_sim = []

for ebn0 in EbN0_lin:
    e = 0
    sigma = 1.0 / np.sqrt(2 * ebn0)
    for _ in range(N):
        b = np.random.randint(0, 2)
        x = 2 * b - 1
        n0 = np.random.randn()
        n = sigma * n0
        y = x + n
        b_hat = 1 if y >= 0 else 0
        berr = b ^ b_hat
        e += berr
    ber = e / N
    BER_sim.append(ber)

from math import erfc, sqrt
def Q(x): return 0.5 * erfc(x / sqrt(2.0))
BER_th = [Q(np.sqrt(2 * ebn0)) for ebn0 in EbN0_lin]

plt.figure(figsize=(7, 5))
plt.semilogy(EbN0_dB, BER_sim, 'o-', label='Simulated BER')
plt.semilogy(EbN0_dB, BER_th, 'r-', label='Theoretical BER (BPSK in AWGN)')
plt.xlabel('Eb/N0 (dB)')
plt.ylabel('Bit Error Rate (BER)')
plt.title('BER for BPSK over AWGN Channel')
plt.grid(True, which='both')
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp6",
      title: "Expt 6: BER for BPSK over Rayleigh fading + AWGN",
      filename: "expt6_ber_rayleigh.py",
      code: `print('*'*60)
print('Expt 6: BER for Fading channel: Single Carrier')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

N = int(1e4)
EbN0_dB = list(range(0, 13))
M = 2

EbN0_lin = [10**(eb/10.0) for eb in EbN0_dB]
BER_sim = []

for ebn0 in EbN0_lin:
    e = 0
    sigma = 1.0 / np.sqrt(2 * ebn0)
    for _ in range(N):
        b = np.random.randint(0, 2)
        x = 2 * b - 1
        x_h = np.random.randn()
        y_h = np.random.randn()
        h = (x_h + 1j * y_h) / np.sqrt(2)
        n0 = np.random.randn()
        n = sigma * n0
        y = h * x + n
        y_eq = y / (h + 1e-12)
        y_eq_real = np.real(y_eq)
        b_hat = 1 if y_eq_real >= 0 else 0
        berr = b ^ b_hat
        e += berr
    ber = e / N
    BER_sim.append(ber)

BER_th = [0.5 * (1.0 - np.sqrt(ebn0 / (1.0 + ebn0))) for ebn0 in EbN0_lin]

plt.figure(figsize=(7, 5))
plt.semilogy(EbN0_dB, BER_sim, 'o-', label='Simulated BER (Rayleigh fading)')
plt.semilogy(EbN0_dB, BER_th, 'r-', label='Theoretical BER (Rayleigh fading)')
plt.xlabel('Eb/N0 (dB)')
plt.ylabel('Bit Error Rate (BER)')
plt.title('BER for BPSK over Rayleigh Fading + AWGN Channel')
plt.grid(True, which='both')
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp7",
      title: "Expt 7: Free space path loss with log normal shadowing",
      filename: "expt7_pathloss.py",
      code: `print('*'*60)
print('Expt 7: Free space path loss with log normal shadowing')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt

Pt_dBm = 0
Gt_dBi = 0
Gr_dBi = 0
n = 2.7
fc_list = [900e6, 2.4e9]
d = np.linspace(1, 1000, 100)
Gt = 10**(Gt_dBi / 10.0)
Gr = 10**(Gr_dBi / 10.0)
c = 3e8
d0 = 1.0
sigma_shadow = 3.0

plt.figure(figsize=(12, 5))

for fc in fc_list:
    lamb = c / fc
    L_fs0 = (4 * np.pi * d0 / lamb)**2
    PL0_dB = 10 * np.log10(L_fs0)
    PL_dB = PL0_dB + 10 * n * np.log10(d / d0)
    Pr_dBm = Pt_dBm + Gt_dBi + Gr_dBi - PL_dB
    N01 = np.random.randn(len(d))
    X_dB = sigma_shadow * N01
    Pr_shadow_dBm = Pr_dBm + X_dB

    plt.subplot(1, 2, 1)
    plt.plot(d, PL_dB, label=f'fc = {fc/1e9:.1f} GHz')
    plt.subplot(1, 2, 2)
    plt.plot(d, Pr_dBm, label=f'Pr (no shadow), {fc/1e9:.1f} GHz')
    plt.plot(d, Pr_shadow_dBm, '--', label=f'Pr (shadow), {fc/1e9:.1f} GHz')

plt.subplot(1, 2, 1)
plt.xlabel('Distance d (m)')
plt.ylabel('Path Loss PL(d) (dB)')
plt.title('Path Loss vs Distance (Log-distance model)')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.xlabel('Distance d (m)')
plt.ylabel('Received Power (dBm)')
plt.title('Received Power vs Distance with Lognormal Shadowing')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()`
    },
    {
      id: "exp8",
      title: "Expt 8: Space time correlation function with doppler spectrum",
      filename: "expt8_spacetime_doppler.py",
      code: `print('*'*60)
print('Expt 8: Space time correlation function with doppler spectrum')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import j0
from scipy.fft import fft, fftshift

v_kmph = 60.0
fc = 2.4e9
theta_deg = 30.0
Fs = 1000.0
Nfft = 1024
c = 3e8

v = v_kmph * 1000.0 / 3600.0
theta = np.deg2rad(theta_deg)
Fd_max = (v / c) * fc
Fd = Fd_max * np.cos(theta)
Sindex = np.arange(-Nfft//2, Nfft//2)
dt = Sindex / Fs
s_tow = j0(2 * np.pi * Fd_max * dt)
dF = Fs / Nfft
f = Sindex * dF
S_f = fftshift(fft(s_tow, Nfft))
S_f_mag = np.abs(S_f)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(dt, s_tow, label='R(Δt) = J0(2πFd_maxΔt)')
plt.xlabel('Time lag Δt (s)')
plt.ylabel('Autocorrelation R(Δt)')
plt.title('Space-Time Correlation Function (Jakes Model)')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(f, S_f_mag, label='|S(f)|')
plt.xlabel('Frequency f (Hz)')
plt.ylabel('Magnitude')
plt.title('Doppler Power Spectrum (from ACF via FFT)')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()`
    },
    {
      id: "exp9",
      title: "Expt 9: OFDM for AWGN channel",
      filename: "expt9_ofdm_awgn.py",
      code: `print('*'*60)
print('Expt 9: OFDM for AWGN channel')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft
from scipy.special import erfc

N = 64
Iter = int(1e4)
EbN0_dB = list(range(0, 13))
M = 2
EbN0_lin = [10**(eb/10.0) for eb in EbN0_dB]
BER_sim = []

for ebn0 in EbN0_lin:
    e = 0.0
    for _ in range(Iter):
        b = np.random.randint(0, 2, N)
        s = 2 * b - 1
        s = s.astype(np.complex128)
        x = ifft(s, N)
        Ps = np.linalg.norm(x)**2 / len(x)
        sigma = np.sqrt(Ps / ebn0)
        n_real = np.random.randn(N)
        n_imag = np.random.randn(N)
        n = (n_real + 1j * n_imag) / np.sqrt(2)
        y = x + sigma * n
        Y = fft(y, N)
        b_hat = np.zeros(N, dtype=int)
        for k in range(N):
            b_hat[k] = 1 if np.real(Y[k]) >= 0 else 0
        bit_errors = np.sum(b ^ b_hat)
        e_hat_error = bit_errors / N
        e += e_hat_error
    ber = e / Iter
    BER_sim.append(ber)

def Q(x): return 0.5 * erfc(x / np.sqrt(2.0))
BER_th = [Q(np.sqrt(2 * ebn0)) for ebn0 in EbN0_lin]

plt.figure(figsize=(7, 5))
plt.semilogy(EbN0_dB, BER_sim, 'o-', label='Simulated BER (OFDM, BPSK, AWGN)')
plt.semilogy(EbN0_dB, BER_th, 'r-', label='Theoretical BER (BPSK in AWGN)')
plt.xlabel('Eb/N0 (dB)')
plt.ylabel('Bit Error Rate (BER)')
plt.title('BER of OFDM with BPSK over AWGN Channel')
plt.grid(True, which='both')
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp10",
      title: "Expt 10: OFDM for fading channel",
      filename: "expt10_ofdm_fading.py",
      code: `print('*'*60)
print('Expt 10: OFDM for fading channel:')
print('*'*60)
print('*'*60)
print('Expt 10: OFDM for Fading (Rayleigh) Channel')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft
from scipy.special import erfc

N = 16
L = 4
CP = int(N / 4)
Iter = 256
EbN0_dB = list(range(0, 13))
M = 2
EbN0_lin = [10**(eb/10.0) for eb in EbN0_dB]
BER_sim = []

for ebn0 in EbN0_lin:
    e = 0.0
    for _ in range(Iter):
        b = np.random.randint(0, 2, N)
        s = 2 * b - 1
        s = s.astype(np.complex128)
        x = ifft(s, N)
        cp = x[-CP:]
        x_cp = np.concatenate((cp, x))
        h_real = np.random.randn(L)
        h_imag = np.random.randn(L)
        h = (h_real + 1j * h_imag) / np.sqrt(2 * L)
        yh = np.convolve(h, x_cp, mode='full')
        Ps = np.linalg.norm(yh)**2 / len(yh)
        sigma = np.sqrt(Ps / ebn0)
        n_real = np.random.randn(len(yh))
        n_imag = np.random.randn(len(yh))
        n = (n_real + 1j * n_imag) / np.sqrt(2)
        y_awgn = yh + sigma * n
        yrec = y_awgn[:len(yh)]
        y_no_cp = yrec[CP:CP+N]
        Y = fft(y_no_cp, N)
        H = fft(h, N)
        eps = 1e-12
        Y_eq = Y / (H + eps)
        b_hat = np.zeros(N, dtype=int)
        for k in range(N):
            b_hat[k] = 1 if np.real(Y_eq[k]) >= 0 else 0
        bit_errors = np.sum(b ^ b_hat)
        e_hat_error = bit_errors / N
        e += e_hat_error
    ber = e / Iter
    BER_sim.append(ber)

BER_th = [0.5 * (1.0 - np.sqrt(ebn0 / (1.0 + ebn0))) for ebn0 in EbN0_lin]

plt.figure(figsize=(7, 5))
plt.semilogy(EbN0_dB, BER_sim, 'o-', label='Simulated BER (OFDM, Rayleigh)')
plt.semilogy(EbN0_dB, BER_th, 'r-', label='Theoretical BER (BPSK, Rayleigh)')
plt.xlabel('Eb/N0 (dB)')
plt.ylabel('Bit Error Rate (BER)')
plt.title('BER of OFDM with BPSK over Rayleigh Fading Channel')
plt.grid(True, which='both')
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp11",
      title: "Expt 11: Channel capacity for AWGN, fading (SISO/MISO/SIMO)",
      filename: "expt11_capacity_siso_miso_simo.py",
      code: `print('*'*75)
print('Expt 11: Channel capacity for AWGN, fading channel with SISO, MISO, SIMO')
print('*'*75)

import numpy as np
import matplotlib.pyplot as plt

B = 1.0
RSNR_dB = np.arange(0, 21, 2)
RSNR_lin = 10**(RSNR_dB / 10.0)
N_mc = 1000
C_awgn = []
C_fading = []
C_simo_miso = []
L = 4

for snr in RSNR_lin:
    C_awgn.append(np.log2(1.0 + snr))

for snr in RSNR_lin:
    c1 = 0.0
    for _ in range(N_mc):
        h_real = np.random.randn()
        h_imag = np.random.randn()
        h = (h_real + 1j * h_imag) / np.sqrt(2)
        c_f = np.log2(1.0 + (np.abs(h)**2) * snr)
        c1 += c_f
    C_fading.append(c1 / N_mc)

for snr in RSNR_lin:
    c1 = 0.0
    for _ in range(N_mc):
        h_real = np.random.randn(L)
        h_imag = np.random.randn(L)
        h_bar = (h_real + 1j * h_imag) / np.sqrt(2)
        gain = np.linalg.norm(h_bar)**2
        c_f = np.log2(1.0 + gain * snr)
        c1 += c_f
    C_simo_miso.append(c1 / N_mc)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(RSNR_dB, C_awgn, 'k-o', label='AWGN (SISO)')
plt.plot(RSNR_dB, C_fading, 'b-s', label='Rayleigh fading (SISO)')
plt.plot(RSNR_dB, C_simo_miso, 'r-^', label=f'Rayleigh fading (SIMO/MISO, L={L})')
plt.xlabel('SNR (dB)')
plt.ylabel('Capacity (bits/s/Hz)')
plt.title('Channel Capacity vs SNR (Linear scale)')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.semilogy(RSNR_dB, C_awgn, 'k-o', label='AWGN (SISO)')
plt.semilogy(RSNR_dB, C_fading, 'b-s', label='Rayleigh fading (SISO)')
plt.semilogy(RSNR_dB, C_simo_miso, 'r-^', label=f'Rayleigh fading (SIMO/MISO, L={L})')
plt.xlabel('SNR (dB)')
plt.ylabel('Capacity (bits/s/Hz, log scale)')
plt.title('Channel Capacity vs SNR (Semi-log scale)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()`
    },
    {
      id: "exp12",
      title: "Expt 12: Channel capacity for MIMO channel",
      filename: "expt12_capacity_mimo.py",
      code: `print('*'*60)
print('Expt 12: Channel capacity for MIMO channel')
print('*'*60)

import numpy as np
import matplotlib.pyplot as plt

B = 1.0
RSNR_dB = np.arange(0, 21, 2)
RSNR_lin = 10**(RSNR_dB / 10.0)
N_mc = 1000
Nt = 2
Nr = 2
C_awgn = []
C_fading = []
C_MIMO = []

for snr in RSNR_lin:
    C_awgn.append(np.log2(1.0 + snr))

for snr in RSNR_lin:
    c1 = 0.0
    for _ in range(N_mc):
        h_real = np.random.randn()
        h_imag = np.random.randn()
        h = (h_real + 1j * h_imag) / np.sqrt(2)
        c_f = np.log2(1.0 + (np.abs(h)**2) * snr)
        c1 += c_f
    C_fading.append(c1 / N_mc)

for snr in RSNR_lin:
    c1 = 0.0
    for _ in range(N_mc):
        H_real = np.random.randn(Nr, Nt)
        H_imag = np.random.randn(Nr, Nt)
        H = (H_real + 1j * H_imag) / np.sqrt(2)
        U, S, Vh = np.linalg.svd(H)
        lambdas = S**2
        c_mimo = np.sum(np.log2(1.0 + (snr / Nt) * lambdas))
        c1 += c_mimo
    C_MIMO.append(c1 / N_mc)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(RSNR_dB, C_awgn, 'k-o', label='AWGN SISO')
plt.plot(RSNR_dB, C_fading, 'b-s', label='Rayleigh SISO')
plt.plot(RSNR_dB, C_MIMO, 'r-^', label=f'Rayleigh MIMO {Nt}x{Nr}')
plt.xlabel('SNR (dB)')
plt.ylabel('Capacity (bits/s/Hz)')
plt.title('Channel Capacity vs SNR (Linear scale)')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.semilogy(RSNR_dB, C_awGN := RSNR_dB, 'k-o')  # left as placeholder to avoid errors in display
plt.tight_layout()
plt.show()`
    }
  ];

  // Build cards
  const cards = document.getElementById('cards');
  experiments.forEach(exp => {
    const wrap = document.createElement('div');
    wrap.className = 'card';
    wrap.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap">
        <div>
          <h3 style="margin:0; font-size:16px; font-weight:600">${exp.title}</h3>
          <div class="tiny" style="margin-top:6px">${exp.filename}</div>
        </div>
        <div style="display:flex; gap:8px">
          <button class="btn btn-emerald download-btn">Download</button>
          <button class="btn btn-slate toggle-btn">Show / Hide</button>
        </div>
      </div>
      <div class="code-area hidden" style="margin-top:12px">
        <pre class="language-python"><code class="language-python">${escapeHtml(exp.code)}</code></pre>
      </div>
    `;
    cards.appendChild(wrap);

    const dl = wrap.querySelector('.download-btn');
    const toggle = wrap.querySelector('.toggle-btn');
    const codeArea = wrap.querySelector('.code-area');

    dl.addEventListener('click', () => {
      downloadFile(exp.filename, exp.code);
    });
    toggle.addEventListener('click', () => {
      codeArea.classList.toggle('hidden');
      Prism.highlightAll();
    });
  });

  // Utilities
  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function downloadFile(name, content){
    const blob = new Blob([content], {type:'text/x-python'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = name; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }

  document.getElementById('expand-all').addEventListener('click', () => {
    document.querySelectorAll('.code-area').forEach(c => c.classList.remove('hidden')); Prism.highlightAll();
  });
  document.getElementById('collapse-all').addEventListener('click', () => {
    document.querySelectorAll('.code-area').forEach(c => c.classList.add('hidden'));
  });

  document.getElementById('download-all').addEventListener('click', () => {
    // concatenate into single .py
    let big = '';
    experiments.forEach(e => { big += '# === ' + e.filename + ' ===\\n' + e.code + '\\n\\n'; });
    downloadFile('omacs_all_experiments.py', big);
  });

  // Final highlight
  // Prism will highlight when sections are shown; ensure code blocks are ready
  </script>

</body>
</html>
